<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>thePirates-Webb</title>
    <link rel="icon" href="https://torrindex.net/images/tpb.jpg" type="image/x-icon">
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet">
    <script type="module">
      // Import the functions you need from the SDKs you need
      import Fuse from 'https://cdn.jsdelivr.net/npm/fuse.js@6.4.6/dist/fuse.esm.js';
      import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-app.js";
      import { getStorage, ref, uploadBytesResumable, getDownloadURL } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-storage.js";
      import { getFirestore, collection, getDoc, getDocs, setDoc, updateDoc, arrayUnion, arrayRemove, deleteDoc, doc, onSnapshot, Timestamp, query } from "https://www.gstatic.com/firebasejs/11.0.1/firebase-firestore.js";

      const servers = {
        iceServers: [
          { urls: "stun:stun.relay.metered.ca:80" },
          { urls: "turn:a.relay.metered.ca:80", username: "a96bdfd48c731dfaa621450e", credential: "RRhbtKq5qXc9ig6N" },
          { urls: "turn:a.relay.metered.ca:80?transport=tcp", username: "a96bdfd48c731dfaa621450e", credential: "RRhbtKq5qXc9ig6N" },
          { urls: "turn:a.relay.metered.ca:443", username: "a96bdfd48c731dfaa621450e", credential: "RRhbtKq5qXc9ig6N" },
          { urls: "turn:a.relay.metered.ca:443?transport=tcp", username: "a96bdfd48c731dfaa621450e", credential: "RRhbtKq5qXc9ig6N" },
        ],
        iceCandidatePoolSize: 10,
      };

      const firebaseConfig = {
        apiKey: "AIzaSyAyc98lCGnLmgMlWu7ONvaCtYVrOQfWBcw",
        authDomain: "nets-5ecc1.firebaseapp.com",
        databaseURL: "https://nets-5ecc1-default-rtdb.firebaseio.com",
        projectId: "nets-5ecc1",
        storageBucket: "nets-5ecc1.appspot.com",
        messagingSenderId: "339199297351",
        appId: "1:339199297351:web:992dd23b62971683f2ee62",
        measurementId: "G-J10YLMN0ZH"
      };
      const app = initializeApp(firebaseConfig);
      const storage = getStorage(app);
      const db = getFirestore(app);

      let currentlyShowing = 'search';
      let searchString = '';
      let checkedOptions = {audio: true, video: true, image: true, application: true, games: true, other: true};
      let status = 'none';

      let webTorrentID = '';
      let messageInput = '';
      let dataChannel = null;
      let messages = 'Messages:';
      let PressedHangUp = false;

      let file = null;
      let fileName = '';
      let receivedChunks = [];
      let totalSize = 0;
      let expectedFileSize = null;
      let isMobile = window.innerWidth <= 768;

      let currentIndex = 0;
      let squares = [];

      function updateView() {
        console.log(squares.length);
        squares.forEach((square, index) => {
        square.classList.add("hidden");
          if (index === currentIndex) {
            square.classList.remove("hidden");
          }
        });
      }

      window.prevSquare = () => {
        currentIndex = (currentIndex === 0) ? squares.length - 1 : currentIndex - 1;
        updateView();
      }

      window.nextSquare = () => {
        currentIndex = (currentIndex === squares.length - 1) ? 0 : currentIndex + 1;
        updateView();
      }

      function concatenateArrayBuffers(arrayBuffers) {
          let totalLength = 0;
          for (let i = 0; i < arrayBuffers.length; i++) {
              totalLength += arrayBuffers[i].byteLength;
          }

          let concatenated = new ArrayBuffer(totalLength);
          let view = new Uint8Array(concatenated);
          let offset = 0;

          for (let i = 0; i < arrayBuffers.length; i++) {
              view.set(new Uint8Array(arrayBuffers[i]), offset);
              offset += arrayBuffers[i].byteLength;
          }

          return concatenated;
      }

      function formatBytes(bytes, decimals = 2) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        console.log(i);
        return parseFloat((bytes / Math.pow(k, i)).toFixed(decimals)) + ' ' + sizes[i];
      }

      function uploadPreviewImage() {
          const fileInput = document.getElementById("previewImage");
          const file = fileInput.files[0];

          if (!file) {
              console.error("No file selected.");
              return Promise.reject("No file selected.");
          }

          // Create storage reference
          const storageRef = ref(storage, `uploads/${file.name}`);
          const uploadTask = uploadBytesResumable(storageRef, file);

          return new Promise((resolve, reject) => {
              uploadTask.on(
                  "state_changed",
                  (snapshot) => {
                      console.log(`Uploading: ${snapshot.bytesTransferred} / ${snapshot.totalBytes}`);
                  },
                  (error) => {
                      console.error("Upload failed:", error);
                      reject(error);
                  },
                  () => {
                      getDownloadURL(uploadTask.snapshot.ref)
                          .then((downloadURL) => {
                              console.log("File available at:", downloadURL);
                              resolve(downloadURL);
                          })
                          .catch(reject);
                  }
              );
          });
      }

      window.showDiv = (name) => {
        // Hide current div
        const currentDiv = document.getElementById(currentlyShowing);
        currentDiv.classList.remove('visible');
        currentDiv.classList.add('hidden');

        currentlyShowing = name;

        // Show new div
        const selectedDiv = document.getElementById(name);
        selectedDiv.classList.remove('hidden');
        selectedDiv.classList.add('visible');
      }
      
      const displayWebTorrents = (torrents, resultsDiv) => {
        // Detect if the device is mobile
        const isMobile = window.innerWidth <= 768;

        console.log(torrents.length);

        if (torrents.length === 0) {
            resultsDiv.innerHTML = `
                <p>Arrrg! No results here â˜ </p>
                <a href="javascript:void(0);" onclick="showDiv('search')">Back</a>
            `;
            return;
        }

        if (isMobile) {
            resultsDiv.innerHTML = `
                <div class="square-container"></div>
                <div class="buttons" style="margin-top: 50px">
                    <a class="card-button" onclick="prevSquare()">â¬… Prev | </a>
                    <a href="javascript:void(0);" onclick="showDiv('search')">Back</a>
                    <a class="card-button" onclick="nextSquare()"> | Next âž¡</a>
                </div>
            `;

            const cardContainer = resultsDiv.querySelector(".square-container");

            torrents.forEach(async (data, index) => {
                const docRef = doc(db, "web-torrents", data.id);
                const docSnapshot = await getDoc(docRef);
                const docData = docSnapshot.data();

                if (checkedOptions[docData.category]) {
                    const card = document.createElement("div");
                    card.className = "square";

                    console.log(card.className);

                    card.innerHTML = `
                        <p class="outlined-text" style="border: 2px dashed black;">Name: ${docData.name}</p>
                        <p class="outlined-text">Category: ${docData.category}</p>
                        <p class="outlined-text">File: ${docData.fileName}</p>
                        <p class="outlined-text">Size: ${formatBytes(docData.fileSize)}</p>
                        <p class="outlined-text">${docData.timestamp.toDate().toLocaleString()}</p>
                        <img src="${docData.previewImage}" alt="Preview Image" width="80" height="80">
                    `;

                    card.onclick = () => LeechWebTorrent(data.id);
                    cardContainer.appendChild(card);
                    squares.push(card);
                }
            });
        } else {
            resultsDiv.innerHTML = `
                <table class="table table-striped table-hover text-left">
                    <thead class="thead-dark">
                        <tr>
                            <th>ðŸ¢ƒ</th>
                            <th>Category</th>
                            <th>Name</th>
                            <th>File Name</th>
                            <th>File Size</th>
                            <th>Timestamp</th>
                            <th>Preview</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                </table>
                <div class="back-button-container">
                    <a href="javascript:void(0);" onclick="showDiv('search')">Back</a>
                </div>
            `;

            const tbody = resultsDiv.querySelector("tbody");

            torrents.forEach(async (data) => {
                const docRef = doc(db, "web-torrents", data.id);
                const docSnapshot = await getDoc(docRef);
                const docData = docSnapshot.data();

                if (checkedOptions[docData.category]) {
                    const tr = document.createElement("tr");
                    tr.innerHTML = `
                        <th style="color: green;">ðŸ¢ƒ</th>
                        <td>${docData.category}</td>
                        <td>${docData.name}</td>
                        <td>${docData.fileName}</td>
                        <td>${formatBytes(docData.fileSize)}</td>
                        <td>
                            ${docData.timestamp.toDate().getFullYear()}-${(docData.timestamp.toDate().getMonth() + 1).toString().padStart(2, "0")}-${docData.timestamp.toDate().getDate().toString().padStart(2, "0")}
                            ${docData.timestamp.toDate().toLocaleTimeString(undefined, { hour: "2-digit", minute: "2-digit" })}
                        </td>
                        <td><img src="${docData.previewImage}" alt="Preview Image" width="80" height="80"></td>
                    `;

                    tr.onclick = () => LeechWebTorrent(data.id);
                    tbody.appendChild(tr);
                }
            });
        }
      };

      window.playAudio = () => {
        const audio = document.getElementById("audio");

        if (audio.paused) {
          audio.play();
        } else {
          audio.pause();
        }
      };

      window.recentWebTorrents = async () => {
        const searchRef = doc(db, 'web-torrents-search', 'Search');
        const searchSnapshot = await getDoc(searchRef);
        const searchResults = searchSnapshot.data().webTorrentSearch;

        // Get the last 100 torrents from the array or all if there are fewer than 100
        let recentTorrents = searchResults.slice(-100);

        const resultsDiv = document.getElementById('results');
        displayWebTorrents(recentTorrents, resultsDiv);

        showDiv('results');
      };

      window.searchWebTorrents = async () => {
        const searchInputBox = document.getElementById('searchInputBox').value;
        const searchRef = doc(db, 'web-torrents-search', 'Search');
        const searchSnapshot = await getDoc(searchRef);
        const searchResults = searchSnapshot.data().webTorrentSearch;

        const fuse = new Fuse(searchResults, {
            keys: ['title']
        });

        const results = fuse.search(searchInputBox).map(result => result.item);
        const resultsDiv = document.getElementById('results');
        displayWebTorrents(results, resultsDiv);

        showDiv('results');
      };

      window.sendMessage = () => {
        if (dataChannel) {
          dataChannel.send(messageInput);
        }
      };

      window.sendFile = () => {
        const reader = new FileReader();

        reader.onload = (e) => {
          const arrayBuffer = e.target.result;
          const chunkSize = 16384; // 16KB chunks
          // Send the file size and name first (as a metadata message)
          const metadata = JSON.stringify({ type: 'meta', size: file.size, name: file.name });
          dataChannel.send(metadata);

          // Send the file chunks
          for (let i = 0; i < arrayBuffer.byteLength; i += chunkSize) {
            dataChannel.send(arrayBuffer.slice(i, i + chunkSize));
          }

          // Send an end message to signal completion
          dataChannel.send(JSON.stringify({ type: 'end' }));
        };

        reader.readAsArrayBuffer(file);
      };

      window.SeedWebTorrent = async () => {
        const nameInput = document.getElementById('nameInput').value;
        const categoryDropdown = document.getElementById('categoryDropdown').value;
        const fileInput = document.getElementById('fileInput');
        //Allow multiple files to be uploaded
        const file = fileInput.files[0];
        let previewImageUrl = '';

        //add uploading preview file to storage
        try {
        // Await the upload function to ensure it completes before logging the URL
        previewImageUrl = await uploadPreviewImage();
        console.log('Preview Image URL:', previewImageUrl);
        } catch (error) {
            console.error('Error uploading preview image:', error);
        }


        status = 'seeding';
        console.log('Seeding Web Torrent:', nameInput, categoryDropdown, file);

        if (!file) {
            alert('Please choose a file to upload.');
            return;
        }

        const timestamp = Timestamp.now();
        const docRef = doc(collection(db, 'web-torrents'));
        const docId = docRef.id;
        webTorrentID = docId;
        const searchRef = doc(db, 'web-torrents-search', 'Search');

        await setDoc(docRef, {
            name: nameInput,
            category: categoryDropdown,
            fileName: file.name,
            fileSize: file.size,
            timestamp: timestamp,
            previewImage: previewImageUrl,
        });

        const searchSnapshot = await getDoc(searchRef);
        if (searchSnapshot.exists()) {
            await updateDoc(searchRef, {
                webTorrentSearch: arrayUnion({ title: nameInput, id: docId })
            });
        } else {
            await setDoc(searchRef, {
                webTorrentSearch: [{ title: nameInput, id: docId }]
            });
        }

        console.log('File information and search data submitted to Firestore:', {
            name: nameInput,
            category: categoryDropdown,
            fileName: file.name,
            fileSize: file.size,
            timestamp: timestamp,
        });

        showDiv('transfer');

        // WebRTC setup
        const pc = new RTCPeerConnection(servers);

        const channel = pc.createDataChannel("chat", { negotiated: true, id: 0 });
        dataChannel = channel;

        channel.onopen = () => {
            console.log('Data channel is open');
            console.log('Sending File');
            window.sendFile();
        };

        dataChannel.onmessage = (event) => {
            const data = event.data;

            if (typeof data === 'string') {
                try {
                    const message = JSON.parse(data);

                    if (message.type === 'meta') {
                        // Initialize to receive file data
                        window.receivedChunks = [];
                        window.fileSize = message.size;
                        window.fileName = message.name;
                        console.log(`Receiving file: ${window.fileName}, Size: ${window.fileSize} bytes`);
                    } else if (message.type === 'end') {
                        // Assemble the file when end message is received
                        const fullArrayBuffer = concatenateArrayBuffers(window.receivedChunks);
                        const blob = new Blob([fullArrayBuffer]);
                        const url = URL.createObjectURL(blob);
                        const downloadLink = document.createElement('a');
                        downloadLink.href = url;
                        downloadLink.download = window.fileName;
                        downloadLink.innerText = 'Download ' + window.fileName;
                        document.getElementById('files').appendChild(document.createElement('br'));
                        document.getElementById('files').appendChild(downloadLink);

                        // Reset state for future file transfers
                        window.receivedChunks = [];
                        window.fileSize = 0;
                        window.fileName = '';
                    }
                } catch (error) {
                    // If parsing fails, it's a normal string message
                    console.error('Error parsing JSON message:', error);
                    console.log('Received message:', data);
                    messages += `\n${data}`;
                    document.getElementById('messages').innerText = messages;
                }
            } else if (data instanceof ArrayBuffer) {
                // Receive file chunks
                window.receivedChunks.push(data);
                const receivedBytes = window.receivedChunks.reduce((sum, chunk) => sum + chunk.byteLength, 0);
                console.log(`Received ${receivedBytes} of ${window.fileSize} bytes`);
            } else {
                // Handle other types of messages if any
                console.log('Received unknown type of message:', data);
            }
        };

        channel.onclose = () => {
            console.log('Data channel is closed, leecher disconnected');
        };

        pc.onicecandidate = (event) => {
            if (event.candidate) {
                console.log("Offer ICE candidate generated: ", event.candidate);
                const iceCandidate = {
                    candidate: event.candidate.candidate,
                    sdpMid: event.candidate.sdpMid,
                    sdpMLineIndex: event.candidate.sdpMLineIndex
                };
                const offerCandidatesRef = collection(docRef, 'offerCandidates');
                const newCandidateDoc = doc(offerCandidatesRef);
                setDoc(newCandidateDoc, iceCandidate);
            }
        };

        const offerDescription = await pc.createOffer();
        await pc.setLocalDescription(offerDescription);

        await updateDoc(docRef, {
            offer: { sdp: offerDescription.sdp, type: offerDescription.type }
        });

        const answerCandidatesRef = collection(docRef, 'answerCandidates');

        onSnapshot(docRef, (snapshot) => {
            const data = snapshot.data();
            const answer = data ? data.answer : null;
            if (!snapshot.exists() && !PressedHangUp) {
              console.log(`Document with ID ${docId} has been deleted CREATING NEW ONE`);
              window.SeedWebTorrent(); // Call seedWebTorrent after deletion
            }

            if (answer) {
                pc.setRemoteDescription(new RTCSessionDescription(answer))
                    .then(() => {
                        console.log('Remote Description Set Successfully');
                    })
                    .catch((error) => {
                        console.error('Error setting remote description:', error);
                    });
            }
        });

        // Listen for remote ICE candidates
        onSnapshot(answerCandidatesRef, (snapshot) => {
            snapshot.docChanges().forEach((change) => {
                if (change.type === 'added') {
                    const candidate = change.doc.data();
                    pc.addIceCandidate(new RTCIceCandidate(candidate))
                        .then(() => {
                            console.log('Answer ICE candidate added successfully');
                        })
                        .catch((error) => {
                            console.error('Error adding answer ICE candidate:', error);
                        });
                }
            });
        });
      };

      window.LeechWebTorrent = async (ID) => {
        webTorrentID = ID;
        showDiv('transfer');

        status = 'leeching';

        const pc = new RTCPeerConnection(servers);

        const channel = pc.createDataChannel("chat", { negotiated: true, id: 0 });
        dataChannel = channel;

        channel.onopen = () => {
          console.log('Data channel is open');
        };

        dataChannel.onmessage = (event) => {
          const data = event.data;

          if (typeof data === 'string') {
            try {
              const message = JSON.parse(data);

              if (message.type === 'meta') {
                // Initialize to receive file data
                window.receivedChunks = [];
                window.fileSize = message.size;
                window.fileName = message.name;
                console.log(`Receiving file: ${window.fileName}, Size: ${window.fileSize} bytes`);
              } else if (message.type === 'end') {
                // Assemble the file when end message is received
                const fullArrayBuffer = concatenateArrayBuffers(window.receivedChunks);
                const blob = new Blob([fullArrayBuffer]);
                const url = URL.createObjectURL(blob);
                const downloadLink = document.createElement('a');
                downloadLink.href = url;
                downloadLink.download = window.fileName;
                downloadLink.innerText = 'Download ' + window.fileName;
                document.getElementById('files').appendChild(document.createElement('br'));
                document.getElementById('files').appendChild(downloadLink);

                // Reset state for future file transfers
                window.receivedChunks = [];
                window.fileSize = 0;
                window.fileName = '';
              }
            } catch (error) {
              // If parsing fails, it's a normal string message
              console.error('Error parsing JSON message:', error);
              console.log('Received message:', data);
              messages += `\n${data}`;
              document.getElementById('messages').innerText = messages;
            }
          } else if (data instanceof ArrayBuffer) {
            // Receive file chunks
            window.receivedChunks.push(data);
            const receivedBytes = window.receivedChunks.reduce((sum, chunk) => sum + chunk.byteLength, 0);
            console.log(`Received ${receivedBytes} of ${window.fileSize} bytes`);
          } else {
            // Handle other types of messages if any
            console.log('Received unknown type of message:', data);
          }
        };

        channel.onclose = () => {
          console.log('Data channel is closed, seeder left');
          showDiv("search");
        };

        pc.onicecandidate = (event) => {
          if (event.candidate) {
            console.log("Answer ICE candidate generated: ", event.candidate);
            const iceCandidate = {
              candidate: event.candidate.candidate,
              sdpMid: event.candidate.sdpMid,
              sdpMLineIndex: event.candidate.sdpMLineIndex
            };
            const callDocRef = doc(db, 'web-torrents', webTorrentID);
            const answerCandidatesRef = collection(callDocRef, 'answerCandidates');
            const newCandidateDoc = doc(answerCandidatesRef); // Auto-generates a unique ID
            setDoc(newCandidateDoc, iceCandidate);
          }
        };

        const callDocRef = doc(db, 'web-torrents', webTorrentID);
        const callDoc = await getDoc(callDocRef);
        const data = callDoc.data();
        const offer = data ? data.offer : null;

        if (offer) {
          pc.setRemoteDescription(new RTCSessionDescription(offer))
            .then(() => {
              console.log('Remote Description Set Successfully');
            })
            .catch((error) => {
              console.error('Error setting remote description:', error);
            });

          const answerDescription = await pc.createAnswer();
          await pc.setLocalDescription(answerDescription);

          await updateDoc(callDocRef, { answer: { sdp: answerDescription.sdp, type: answerDescription.type } });

          const offerCandidatesRef = collection(callDocRef, 'offerCandidates');

          // Add existing offer ICE candidates
          onSnapshot(offerCandidatesRef, (snapshot) => {
            snapshot.docChanges().forEach((change) => {
              if (change.type === 'added') {
                const candidate = change.doc.data();
                pc.addIceCandidate(new RTCIceCandidate(candidate))
                  .then(() => {
                    console.log('Offer ICE candidate added successfully');
                  })
                  .catch((error) => {
                    console.error('Error adding offer ICE candidate:', error);
                  });
              }
            });
          });
        }
      };

      window.hangUp = async () => {
        PressedHangUp = true;
        const callDocRef = doc(db, 'web-torrents', webTorrentID);
        const searchRef = doc(db, 'web-torrents-search', 'Search');

        // Delete the call document
        await deleteDoc(callDocRef);

        // Remove the web torrent from the search array
        const searchSnapshot = await getDoc(searchRef);
        if (searchSnapshot.exists()) {
            const existingData = searchSnapshot.data().webTorrentSearch;
            const itemToRemove = existingData.find(item => item.id === webTorrentID);
            if (itemToRemove) {
                await updateDoc(searchRef, {
                    webTorrentSearch: arrayRemove(itemToRemove)
                });
            }
        }

        showDiv("search");

        // Close data channel and peer connection
        if (dataChannel) {
            dataChannel.close();
        }
        dataChannel = null;

        // Reset messages
        messages = '[Messages]';
        document.getElementById('messages').innerText = messages;
      };

      window.showTab = function(tabId, btn) {
        // Hide all articles
        document.querySelectorAll("#news .tab").forEach(tab => tab.style.display = "none");
        // Show the selected article
        document.getElementById(tabId).style.display = "block";
        // Remove 'active' from all buttons
        document.querySelectorAll("#news .nav button").forEach(button => button.classList.remove("active"));
        // Add 'active' to the clicked button
        btn.classList.add("active");
      };

      document.addEventListener('DOMContentLoaded', () => {

        window.addEventListener("beforeunload", async (event) => {
          console.log("Attempting async cleanup...");
          await window.hangUp(); // Might complete if the browser allows time
        });

        //Changes the label of the file input
        document.getElementById("fileInput").addEventListener("change", function () {
          let fileName = this.files.length > 0 ? this.files[0].name : "Choose file...";
          document.getElementById("fileUploadLabel").textContent = fileName;
        });
        
        //Changes the label of the preview image input
        document.getElementById("previewImage").addEventListener("change", function () {
          let fileName = this.files.length > 0 ? this.files[0].name : "Preview Image (optional)";
          document.getElementById("previewImageLabel").textContent = fileName;
        });

        // Search Input Box
        document.getElementById('searchInputBox').addEventListener('input', (e) => {
            searchString = e.target.value;
        });

        // Message Input Box
        document.getElementById('messageInputBox').addEventListener('input', (e) => {
            messageInput = e.target.value;
        });

        // File Input
        document.getElementById('fileInput').addEventListener('change', (e) => {
            file = e.target.files[0];
            if (file) {
                console.log('File selected:', file.name);
            }
        });

        // Preview Image Input
        document.getElementById('previewImage').addEventListener('change', (e) => {
            if (file) {
                console.log('Preview Image:', file.name);
            }
        });

        // Checkbox Event Listeners
        const checkboxes = ['audio', 'video', 'image', 'application', 'games', 'other'];
        checkboxes.forEach((name) => {
            document.getElementById(`${name}Checkbox`).addEventListener('change', (e) => {
                if (e.target.checked) {
                    checkedOptions[name] = true;
                } else {
                    delete checkedOptions[name];
                }
                console.log('Checked Options:', checkedOptions);
            });
        });
      });
    </script>
    <style>
      body {
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        background-color: #ffffff;
      }
      .coptions {
        margin-bottom: 15px;
      }
      .hidden { 
        display: none; 
      } 
      .visible { 
        display: block; 
        text-align: center;
      }
      .raised-button {
        font-size: 20px;
        font-weight: bold;
        padding: 15px 30px;
        color: white;
        background: #007bff;
        border: none;
        border-radius: 10px;
        cursor: pointer;
        box-shadow: 0 5px #0056b3;
        transition: 0.3s;
      }

      .raised-button:hover {
        box-shadow: 0 2px #0056b3;
        transform: translateY(3px);
      }
      .search-box input[type="search"] {
        width: 80%;
        padding: 10px;
        font-size: 16px;
      }

      .search-box input[type="submit"] {
        padding: 10px 20px;
        font-size: 16px;
        background-color: #343a40;
        color: white;
        border: none;
        cursor: pointer;
      }

      .search-box input[type="submit"]:hover {
        background-color: #23272b;
      }

      footer {
        margin-top: 20px;
      }
      

      .block {
        position: relative;
        background: #f6e2c6;
        text-align: left;
        margin: 22px;
      }

      .block:before, .block:after {
        content: '';
        position: absolute;
        left: -4px;
        top: -4px;
        background: linear-gradient(45deg, #f2ff62, #ff8e38, #b77c50,#ffcda7, #ffdd47, #ffd558, 
          #f7bb5b, #ffce51,#F5F1EE, #F5F1EE);
        background-size: 400%;
        width: calc(100% + 10px);
        height: calc(100% + 10px);
        z-index: -1;
        animation: steam 20s linear infinite;
      }

      @keyframes steam {
        0% {
          background-position: 0 0;
        }
        50% {
          background-position: 400% 0;
        }
        100% {
          background-position: 0 0;
        }
      }

      .block:after {
        filter: blur(50px);
      }   

      .vid-btn-container {
        position: relative;
        width: 200px;
        height: 60px;
      }

      video {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        object-fit: cover;
        border: 3px solid rgb(117, 71, 32);
        border-radius: 3px; /* Makes it look stylish */
        box-shadow: 0 6px 8px rgba(0, 0, 0, 0.3);
      }

      .vid-btn {
        position: absolute;
        width: 100%;
        height: 100%;
        background: transparent;
        border: none;
        font-size: 18px;
        font-weight: bold;
        color: #fbfbfb;
        text-shadow: 2px 2px 4px rgba(135, 98, 46, 0.5); /* Adds a visible shadow */
        cursor: pointer;
        outline: none;
      }


      .vid-btn:hover {
        opacity: 0.87;
      }

      .table-striped tbody tr:nth-of-type(odd) {
        background-color: #F5F1EE; /* Light background for odd rows */
      }

      .table-striped tbody tr:nth-of-type(even) {
        background-color: #F1ECE7; /* Light background for even rows */
      }

      /* On hover, turn row background white */
      .table-striped tbody tr:hover {
        background-color: white !important;
      }

      .back-button-container {
        display: flex;
        justify-content: flex-start; /* Align to the bottom left */
        margin-top: 20px;
      }

      .square-container {
        position: relative;
        width: 400px;
        height: 450px;
      }

      .square {
        position: absolute;
        width: 100%;
        height: 100%;
        background-color: #d6eaf8; /* Blueish-white */
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        font-size: 20px;
        padding: 20px;
        color: #2c3e50;
        font-weight: bold; /* thanx*/
        border-radius: 15px; /* Smooth corners */
        box-shadow: 5px 5px 15px rgba(0, 0, 0, 0.2); /* Shadow effect */
        transition: opacity 0.5s ease, transform 0.5s ease;
      }

      .outlined-text {
        font-size: 22px;
        font-weight: bold;
        color: white;
        text-shadow: 
            -1px -1px 0 black, 
            1px -1px 0 black, 
            -1px 1px 0 black, 
            1px 1px 0 black; /* Creates the outline effect */
        padding: 5px;
        letter-spacing: 2px;
      }

      .hidden {
        opacity: 0;
        transform: scale(0.8);
      }

      .text-left {
        text-align: left; /* Align all text to the left */
      }

      .back-button-container {
          margin-top: 20px;
      }

      /* Change to be invisible and image on click plays audio */
      audio {
        display: none;
      }

      #news .nav {
        display: flex;
        gap: 10px;
        margin-bottom: 15px;
      }
      #news .nav button {
        padding: 12px;
        font-size: 16px;
        border: none;
        background-color: #007f5f;
        color: white;
        cursor: pointer;
        border-radius: 5px;
        box-shadow: 2px 2px 4px #999;
        transition: all 0.1s ease-in-out;
      }
      #news .nav button:hover {
        background-color: #005f46;
      }
      #news .nav button.active {
        box-shadow: inset 2px 2px 4px #666;
        transform: translateY(2px);
      }
      #news .tab {
        display: none;
        max-width: 800px;
        min-width: 800px;
        min-height: 340px;
        max-height: 340px;
        padding: 20px;
        background-color: white;
        border-radius: 10px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        text-align: left;
        margin-bottom: 20px;
        box-sizing: border-box;
        overflow: auto;
      }

      /* Responsive: Make news square fit mobile screens */
      @media (max-width: 900px) {
        #news .tab {
          max-width: 98vw;
          min-width: 0;
          min-height: 220px;
          max-height: none;
          padding: 10px;
        }
      }
      #news .meta {
        font-size: 14px;
        color: #666;
      }
      #news .article-content {
        line-height: 1.6;
      }
      #news .footer {
        margin-top: 20px;
        font-size: 12px;
        color: #888;
      }
    </style>
</head>
<body>
  <div>
    <div class="hidden" id="transfer">
      <div class="coptions" style="margin-top: 10px;">
          <div id="files" style="margin-bottom: 10px; text-align: left;">[File/s]</div>
          <div id="messages" style="margin-bottom: 10px; text-align: left;">[Chat]</div>
      </div>

      <div class="coptions d-flex flex-column">
          <div class="d-flex align-items-center">
              <input type="text" id="messageInputBox" placeholder="Enter message" class="form-control">
              <a onclick="sendMessage()" class="btn btn-primary ml-2" style="margin-right: 10px;">Send</a>
              <a onclick="hangUp()" class="btn btn-secondary">Leave</a>
          </div>
      </div>
    </div>
    <div class="visible" id="search">
      <header>
          <nav>
            <section>
              <img onclick="playAudio()" src="https://i.postimg.cc/LXpzPJzR/The-Pirates-Web-1.png"
                style="opacity: 0; transition: opacity 1s ease-in-out;" onload="this.style.opacity='1'">
            </section>
            <div class="player">
              <audio id="audio" controls autoplay>
                <source src="https://lit2talks.com/tool/uploads/68322476650f6_Pirates%20of%20the%20Caribbean%20%20Theme%20Song%20%20Hes%20a%20Pirate%201080p%20HD.mp3" type="audio/mpeg">
              </audio>
            </div>
            <section>
                <strong>Search Torrents</strong>
                <a href="javascript:void(0);" onclick="recentWebTorrents()" title="Recent Torrents">Recent&nbsp;Torrents</a>
            </section>
          </nav>
      </header>
      <main>     
        <div class="input-group mb-3 d-flex justify-content-center" style="align-items: center; margin-top: 10px;">
          <input type="text" id="searchInputBox" class="form-control" placeholder="Pirates of the Caribean" value="" style="max-width: 200px; margin-left: 10px;">
          <button class="raised-button" style="margin-left: 10px;" onclick="searchWebTorrents()">Search</button>
        </div>   
        <div class="coptions">
            <label><input type="checkbox" id="audioCheckbox" checked> Audio</label>
            <label><input type="checkbox" id="videoCheckbox" checked> Video</label>
            <label><input type="checkbox" id="imageCheckbox" checked> Image</label>
            <label><input type="checkbox" id="applicationCheckbox" checked> Application</label>
            <label><input type="checkbox" id="gamesCheckbox" checked> Games</label>
            <label><input type="checkbox" id="otherCheckbox" checked> Other</label>
        </div>
        <a href="javascript:void(0);" onclick="showDiv('upload')" title="Upload Web Torrent">Upload Web Torrent</a>
        <a href="javascript:void(0);" onclick="showDiv('news')" title="News"> | News</a>
      </main>    
    </div>
    <div class="hidden" id="results">
    </div>
    <div class="hidden block" id="upload">
      <div>
          <div class="form-group" style="width: 80%;">
              <label for="nameInput" class="font-weight-bold">Name</label>
              <input type="text" class="form-control" id="nameInput" placeholder="Enter name" required>
          </div>
          <div class="form-group" style="width: 45%;">
              <label for="categoryDropdown" class="font-weight-bold">Category</label>
              <select class="form-control" id="categoryDropdown" required>
                  <option value="audio">Audio</option>
                  <option value="video">Video</option>
                  <option value="image">Image</option>
                  <option value="application">Application</option>
                  <option value="games">Games</option>
                  <option value="other">Other</option>
              </select>
          </div>
          <div class="form-group" style="width: 70%;">
            <label for="fileInput" class="font-weight-bold">Upload File</label>
            <div class="custom-file">
                <input type="file" class="custom-file-input" id="fileInput" required>
                <label class="custom-file-label" for="fileInput" id="fileUploadLabel">Choose file...</label>
            </div>
          </div>
          <div class="form-group" style="width: 70%;">
            <label for="previewImage" class="font-weight-bold">Upload Preview Image</label>
            <div class="custom-file">
                <input type="file" class="custom-file-input" id="previewImage" accept="image/*">
                <label class="custom-file-label" for="previewImage" id="previewImageLabel">Preview Image (optional)</label>
            </div>
          </div>
          <button class="raised-button" onclick="SeedWebTorrent()">Upload Web Torrent</button>
      </div>
      <a href="javascript:void(0);" style="padding: 0 0 10px 30px; display: inline-block; text-align: left;" onclick="showDiv('search')">Back</a>
    </div>  
    <div class="hidden" id="news" style="font-family: Arial, sans-serif; max-width: 900px; margin: 0 auto; padding: 20px; text-align: left;">
      <div class="nav" style="margin-bottom: 15px;">
          <button onclick="showTab('worldNews', this)" id="btn-world">World News</button>
          <button onclick="showTab('technologyNews', this)" id="btn-tech">Technology</button>
          <button onclick="showTab('sportsNews', this)" id="btn-sports">Sports</button>
          <button onclick="showDiv('search')" style="margin-left: auto; background:#0c79ff;">Back</button>
      </div>

      <div id="worldNews" class="tab" style="display: block;">
          <h1 style="color: #007f5f; margin-left: 10px;">Breaking News: Global Affairs Update</h1>
          <p class="meta">By Jane Doe | Published on May 28, 2025</p>
          <div class="article-content">
              <p>World leaders gather for a high-stakes summit on climate change, aiming to set new sustainability goals.</p>
              <p>Diplomatic tensions rise as trade negotiations continue between major economies.</p>
          </div>
          <p class="footer">Â© 2025 News Network | All rights reserved.</p>
      </div>

      <div id="technologyNews" class="tab">
          <h1 style="color: #007f5f; margin-left: 10px;">Breaking News: Tech Innovation Revolution</h1>
          <p class="meta">By Alex Johnson | Published on May 28, 2025</p>
          <div class="article-content">
              <p>AI-driven automation reshapes industries, as companies invest in cutting-edge tech solutions.</p>
              <p>The rise of quantum computing sparks debates on data security and encryption.</p>
          </div>
          <p class="footer">Â© 2025 News Network | All rights reserved.</p>
      </div>

      <div id="sportsNews" class="tab">
          <h1 style="color: #007f5f; margin-left: 10px;">Breaking News: Sports Championship</h1>
          <p class="meta">By Chris Williams | Published on May 28, 2025</p>
          <div class="article-content">
              <p>An underdog team secures victory in a nail-biting championship finale, stunning fans worldwide.</p>
              <p>Top athletes gear up for the upcoming Olympic Games, promising record-breaking performances.</p>
          </div>
          <p class="footer">Â© 2025 News Network | All rights reserved.</p>
      </div>
    </div>
  </div>
</body>
</html>
